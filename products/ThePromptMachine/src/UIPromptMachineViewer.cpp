/*
    UIPromptMachineViewer.cpp
    
///
/// CBTek LLC ("COMPANY") CONFIDENTIAL
/// Copyright (c) 2016 CBTek, All Rights Reserved.
///
/// NOTICE:  All information contained herein is, and remains the property of COMPANY. The intellectual and technical concepts contained
/// herein are proprietary to COMPANY and may be covered by U.S. and Foreign Patents, patents in process, and are protected by trade secret or copyright law.
/// Dissemination of this information or reproduction of this material is strictly forbidden unless prior written permission is obtained
/// from COMPANY.  Access to the source code contained herein is hereby forbidden to anyone except current COMPANY employees, managers or contractors who have executed
/// Confidentiality and Non-disclosure agreements explicitly covering such access.
///
/// The copyright notice above does not evidence any actual or intended publication or disclosure  of  this source code, which includes
/// information that is confidential and/or proprietary, and is a trade secret, of  COMPANY.   ANY REPRODUCTION, MODIFICATION, DISTRIBUTION, PUBLIC  PERFORMANCE,
/// OR PUBLIC DISPLAY OF OR THROUGH USE  OF THIS  SOURCE CODE  WITHOUT  THE EXPRESS WRITTEN CONSENT OF COMPANY IS STRICTLY PROHIBITED, AND IN VIOLATION OF APPLICABLE
/// LAWS AND INTERNATIONAL TREATIES.  THE RECEIPT OR POSSESSION OF  THIS SOURCE CODE AND/OR RELATED INFORMATION DOES NOT CONVEY OR IMPLY ANY RIGHTS
/// TO REPRODUCE, DISCLOSE OR DISTRIBUTE ITS CONTENTS, OR TO MANUFACTURE, USE, OR SELL ANYTHING THAT IT  MAY DESCRIBE, IN WHOLE OR IN PART.
///

*/
//UIPromptMachineViewer.cpp generated by cbtek on 10-23-2016 at 01:33:03 PM

#include "UIPromptMachineViewer.h"
#include "ui_UIPromptMachineViewer.h"

#include <QScrollBar>
#include <QPainter>

#include "qt_utility/inc/UIUtils.hpp"

#include "utility/inc/StringUtils.hpp"

using namespace cbtek::common::qt_utility;
using namespace cbtek::common::utility;

namespace cbtek {
namespace products {
namespace productivity {
namespace prompt_machine {


UIPromptMachineViewer::UIPromptMachineViewer(const PromptSession & session,
                                             QWidget *parent) :
    QMainWindow(parent),
    m_ui(new Ui_UIPromptMachineViewer)
{
    m_session = session;
    m_ui->setupUi(this);
    m_browser = new QTextBrowser;

    m_isCountDownMode = true;
    m_isFullScreen = false;
    this->setCentralWidget(m_browser);
    m_browser->hide();
    onToggleFullScreen();
    m_countDownSeconds = 0;
    m_textHeight = 0;
    m_scrollSpeed = m_session.getInitialScrollSpeed();
    QTimer::singleShot(100,this,SLOT(onInit()));

    m_browser->setReadOnly(true);
}

UIPromptMachineViewer::~UIPromptMachineViewer()
{
    delete m_ui;
}

void UIPromptMachineViewer::resizeEvent(QResizeEvent *)
{
    if (m_isCountDownMode)
    {
        QFontMetrics metrics  = m_browser->fontMetrics();
        m_textHeight = metrics.height();
        int count = 1;
        if (m_textHeight > 0 )
        {
            count = (m_browser->height()/m_textHeight)+1;
        }
        QString textWithBlanks = QString::fromStdString(StringUtils::repeat("\n\n",count)) + m_browser->toPlainText();
        m_browser->setPlainText(textWithBlanks);
    }
}

void UIPromptMachineViewer::keyReleaseEvent(QKeyEvent * e)
{
    if (e->key() == Qt::Key_Escape)
    {
        onToggleFullScreen();
    }
    else if (e->key() == Qt::Key_Up)
    {
        m_scrollSpeed-=5;
        if (m_scrollSpeed < 1)
        {
            m_scrollSpeed = 1;
        }
        m_scrollTimer.start(101-m_scrollSpeed);

    }
    else if (e->key() == Qt::Key_Down)
    {
        m_scrollSpeed+=5;
        if (m_scrollSpeed > 100)
        {
            m_scrollSpeed = 100;
        }
        m_scrollTimer.start(101-m_scrollSpeed);
    }
}

void UIPromptMachineViewer::paintEvent(QPaintEvent *event)
{


    QMainWindow::paintEvent(event);
    QPainter g(this);
    QRect screenArea = QRect(0,0,this->width(),this->height());
    if (m_isCountDownMode)
    {
        QTextOption option;

        option.setAlignment(Qt::AlignCenter);



        QFont font = UIUtils::getAutoFont("000",this->width()-32,256);
        g.setFont(font);
        g.fillRect(screenArea,m_session.getPageBackgroundColor());
        g.setPen(m_session.getTextForegroundColor());
        g.drawImage(screenArea,
                    m_textOverlay);
        g.drawText(screenArea,
                   QString::number(m_countDownSeconds),
                   option);

    }
    else
    {
//        g.drawImage(screenArea,
//                    m_textOverlay);
    }
}

void UIPromptMachineViewer::onToggleFullScreen()
{
    m_isFullScreen  = !m_isFullScreen;
    if (m_isFullScreen)
    {
        this->setWindowState( Qt::WindowMaximized |
                              Qt::WindowFullScreen);
    }
    else
    {
        this->setWindowState(Qt::WindowNoState);
    }
}

void UIPromptMachineViewer::onInit()
{
    //Set properties for session
    m_browser->setWordWrapMode(QTextOption::WordWrap);
    m_browser->setPlainText(m_session.getText());
    m_browser->setFont(QFont("arial",m_session.getTextSize()));
    m_browser->setStyleSheet("QTextBrowser{background: "+UIUtils::toHTMLColorRGBString(m_session.getPageBackgroundColor())+
                             "; color: "+UIUtils::toHTMLColorRGBString(m_session.getTextForegroundColor())+";}");

    //calculate number of blanks to precede start of text
    QFontMetrics metrics  = m_browser->fontMetrics();
    m_textHeight = metrics.height();
    int count = 1;
    if (m_textHeight > 0 )
    {
        count = (m_browser->height()/m_textHeight)+1;
    }
    QString textWithBlanks = QString::fromStdString(StringUtils::repeat("\n",count)) + m_browser->toPlainText();
    m_browser->setPlainText(textWithBlanks);

    QScrollBar * bar = m_browser->verticalScrollBar();
    if (bar)
    {
        bar->hide();
    }
    //load overlay images and
    //connect timers to functions for countdown and scroll modes
    m_countDownOverlay.load(":/cbtek/products/productivity/prompt_machine/images/imgMovieFilm.png");
    m_textOverlay.load(":/cbtek/products/productivity/prompt_machine/images/imgPromptOverlay.png");
    connect(&m_countDownTimer,SIGNAL(timeout()),this,SLOT(onUpdateCountDown()));
    connect(&m_scrollTimer,SIGNAL(timeout()),this,SLOT(onUpdateTextScroll()));
    m_countDownSeconds = m_session.getTimeoutSeconds()+1;
    onUpdateCountDown();
    m_countDownTimer.start(1000);
}

void UIPromptMachineViewer::onUpdateCountDown()
{
    m_countDownSeconds--;
    if (m_countDownSeconds < 0)
    {
        m_countDownTimer.stop();
        m_isCountDownMode = false;
        m_browser->show();
        m_scrollTimer.start(101-m_scrollSpeed);
    }
    update();
}

void UIPromptMachineViewer::onUpdateTextScroll()
{
    QScrollBar * bar = m_browser->verticalScrollBar();
    if (bar)
    {
        bar->setSliderPosition(m_browser->verticalScrollBar()->sliderPosition()+2);
    }
    update();
}

void UIPromptMachineViewer::onStart()
{

}

}}}}//end namespace

